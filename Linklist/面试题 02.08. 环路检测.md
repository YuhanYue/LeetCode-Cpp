#### [面试题 02.08. 环路检测](https://leetcode-cn.com/problems/linked-list-cycle-lcci/)

**Description**

给定一个链表，如果它是有环链表，实现一个算法返回环路的开头节点。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。



**Example**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。

```

**Solution**

![fig1](https://assets.leetcode-cn.com/solution-static/jindian_02.08/jindian_02.08.png)

*a*+(*n*+1)*b*+*n**c*=2(*a*+*b*)⟹*a*=*c*+(*n*−1)(*b*+*c*)

**Code**

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *slow = head, *fast = head;
        while(fast!= nullptr){
            slow = slow->next;
            if(fast->next == nullptr) return nullptr;
            fast = fast->next->next;
            if(fast == slow){
                 ListNode* ptr = head;
                 while(ptr != slow){
                     ptr = ptr->next;
                     slow = slow->next;
                 }
                 return ptr;
            }

        }
        return nullptr;
    }
};
```



