#### [148. Sort List](https://leetcode-cn.com/problems/sort-list/)

**Description**

Given the head of a linked list, return the list after sorting it in ascending order.

Follow up: Can you sort the linked list in O(n logn) time and O(1) memory (i.e. constant space)?





**Example**

![img](https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg)



**Solution**

* #### 方法一：自顶向下归并排序

  对链表自顶向下归并排序的过程如下。

  找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 22 步，慢指针每次移动 11 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。

  对两个子链表分别排序。

  将两个排序后的子链表合并，得到完整的排序后的链表。可以使用「21. 合并两个有序链表」的做法，将两个有序的子链表进行合并。

  上述过程可以通过递归实现。递归的终止条件是链表的节点个数小于或等于 11，即当链表为空或者链表只包含 11 个节点时，不需要对链表进行拆分和排序。

  

**Code**

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        return Divide(head, nullptr);
    }

    ListNode* Divide(ListNode* head, ListNode* tail){
        //递归终止的两个条件：1. 空节点 2. 只有一个节点
        if(head == nullptr) return nullptr;
        if(head->next == tail){
            head->next = nullptr;
            return head;
        } 

        ListNode* slow = head;
        ListNode* fast = head;
        while(fast != tail){
            slow = slow->next;
            fast = fast->next;
            if(fast!=tail) fast = fast->next;
        }
        ListNode* mid = slow;
        return Merge(Divide(head, mid), Divide(mid, tail));//后面为什么不是mid->next
    }

    ListNode* Merge(ListNode* head1, ListNode* head2){
        ListNode* res = new ListNode;
        ListNode* ans = res;
        while(head1 && head2){
            if(head1->val <= head2->val){
                res->next = head1;
                head1 = head1->next;
            }
            else{
                res->next = head2;
                head2 = head2->next;
            }
            res = res->next;
        }
        if(head1||head2){
            res->next = head1? head1 : head2;
        }
        return ans->next;
    }
};


```



