#### [96. Unique Binary Search Trees](https://leetcode-cn.com/problems/unique-binary-search-trees/)

**Description**

Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.



**Examples**



![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```
Input: n = 3
Output: 5
```



**Solution**  

* 动态规划

  当输入为n时，n个节点有G(n)种不同的二叉搜索树。

  当以第i个节点为根节点时，有f(i)棵不同的二叉搜索树。 f(i) = G(i-1)*G(n-i);

  所以*G*(*n*)=*i*=1∑*n**G*(*i*−1)⋅*G*(*n*−*i*)

  

  **Code**

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> G(n+1, 0);
        G[0] = 1;
        G[1] = 1;
        
        for(int i = 2; i <=n ; i++){
            for(int j = 1; j<=i; j++){
                G[i] += G[j-1]*G[i-j];
            }
        }

        return G[n];
    }
};
```



